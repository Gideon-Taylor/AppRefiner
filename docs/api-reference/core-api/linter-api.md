# Linter API

The Linter API provides interfaces and classes for implementing code analysis and issue detection in AppRefiner. This document describes the core components of the Linter API and how to use them effectively.

## Overview

The Linter API is built on top of the ANTLR4 parsing framework and uses a visitor pattern to analyze PeopleCode syntax trees. The main components of this API are:

- `BaseLintRule`: The abstract base class for all linting rules
- `Report`: Represents an issue found during linting
- `ReportType`: Enumeration of severity levels for reports
- `LinterSuppressionListener`: Handles suppressing linter warnings via comments

## BaseLintRule

`BaseLintRule` is the foundation of all linting rules in AppRefiner. It extends `PeopleCodeParserBaseListener` from ANTLR4, allowing it to listen for specific grammar patterns in the code.

```csharp
public abstract class BaseLintRule : PeopleCodeParserBaseListener
{
    // Linter ID must be set by all subclasses
    public abstract string LINTER_ID { get; }

    public bool Active = false;
    public string Description = "Description not set";
    public ReportType Type;
    public List<Report>? Reports;
    public virtual DataManagerRequirement DatabaseRequirement => DataManagerRequirement.NotRequired;
    public IDataManager? DataManager;

    // Add collection to store comments from lexer
    public IList<IToken>? Comments;

    // The suppression listener shared across all linters
    public LinterSuppressionListener? SuppressionListener;

    public abstract void Reset();

    // Helper method to create a report
    protected void AddReport(int reportNumber, string message, ReportType type, int line, (int Start, int Stop) span);
}
```

### Key Properties and Methods

- `LINTER_ID`: A unique identifier for the linter rule (must be implemented by subclasses)
- `Active`: Whether the linter rule is currently enabled
- `Description`: Human-readable description of what the rule checks for
- `Type`: Default severity level for reports generated by this rule
- `Reports`: Collection of issues found during analysis
- `DatabaseRequirement`: Specifies if this linter requires database access
- `Reset()`: Resets the linter state between analyses
- `AddReport()`: Creates and adds a new report, handling suppression checks

## Report

The `Report` class represents a single issue found during linting:

```csharp
public class Report
{
    public string Message = "";
    public ReportType Type;
    public int Line;
    public (int Start, int Stop) Span;
    public string? Text;
    public string? Detail;
    public bool IsError => Type == ReportType.Error;
    public bool IsWarning => Type == ReportType.Warning;
    public bool IsInfo => Type == ReportType.Info;

    // Fields for identifying reports for suppression
    public string LinterId { get; set; } = string.Empty;
    public int ReportNumber { get; set; }

    // Helper method to get the full identifier of a report
    public string GetFullId() => $"{LinterId}:{ReportNumber}";
}
```

### Key Properties

- `Message`: The human-readable description of the issue
- `Type`: The severity level (Error, Warning, Info, etc.)
- `Line`: The line number where the issue was found
- `Span`: The character range in the source code
- `LinterId`: The ID of the linter that generated this report
- `ReportNumber`: A numeric identifier for this specific type of report
- `GetFullId()`: Returns the combined ID used for suppression

## ReportType

The `ReportType` enumeration defines the possible severity levels for linter reports:

```csharp
public enum ReportType
{
    GrayOut,  // Used for code that should be visually de-emphasized
    Style,    // Style suggestions
    Error,    // Critical issues that should be fixed
    Warning,  // Potential problems
    Info      // Informational messages
}
```

## Creating a Custom Linter

To create a custom linter, extend the `BaseLintRule` class and implement the required methods:

```csharp
public class MyCustomLinter : BaseLintRule
{
    public override string LINTER_ID => "MY_CUSTOM_LINTER";

    public MyCustomLinter()
    {
        Description = "Checks for a specific pattern in the code";
        Type = ReportType.Warning;
        Active = true;
    }

    // Override methods from PeopleCodeParserBaseListener to analyze specific syntax
    public override void EnterSomeGrammarRule(SomeGrammarRuleContext context)
    {
        // Analyze the context and add reports if issues are found
        if (SomeCondition)
        {
            AddReport(
                1,                  // Report number
                "Issue description", // Message
                Type,               // Severity
                context.Start.Line - 1, // Line number (0-indexed)
                (context.Start.StartIndex, context.Stop.StopIndex + 1) // Character span
            );
        }
    }

    public override void Reset()
    {
        // Reset any internal state
        Reports?.Clear();
    }
}
```

## Linter Suppression

AppRefiner supports suppressing linter warnings through special comments in the code:

```
/* @lint-disable LINTER_ID */
// Code with suppressed linting
/* @lint-enable LINTER_ID */
```

Or for a single line:

```
someCode(); // @lint-ignore LINTER_ID
```

The `LinterSuppressionListener` class handles parsing these comments and determining which reports should be suppressed.

## Best Practices

1. **Unique IDs**: Ensure your linter has a unique, descriptive ID
2. **Clear Messages**: Write clear, actionable messages for reports
3. **Performance**: Keep linters efficient, especially for large files
4. **Configurability**: Allow users to adjust severity levels
5. **Documentation**: Document what your linter checks for and why

## See Also

- [Refactor API](refactor-api.md)
- [Styler API](styler-api.md)
- [Creating Custom Linters](../extension-api/custom-linters.md)
